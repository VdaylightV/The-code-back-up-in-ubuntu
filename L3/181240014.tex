\documentclass[UTF8]{ctexart}
\title{实验报告}
\author{甘晨 181240014}
\date{\today}
\begin{document}
\maketitle
\subsection{L1}
\subsubsection{设计思路}
\par 我对空闲空间的管理主要考虑了两种方法：

\par 一:根据课本上描述的设置头块的方法，在堆区的空闲空间内部建立空闲列表。然而，具体实现过程中，发现这种方法不仅复杂，每次分配空间时需要对空闲空间的头块和已分配的空间的头块都要做迁移，十分容易出错；此外，每次的空间分配和回收以及头块迁移，都会导致部分空间被浪费，堆区空间碎片化严重，因此放弃了这种方法。

\par 二:采取了分页的思想，由于实验要求给出假设，最大内存分配不超过4KiB，因此，可以将堆区空间划分成多个页，每一个页的头部划分出一个区间块存储每一页的使用情况，包括是否已满，该页的brk以及指向下一页的指针。这样设计的一大好处是，对于以4KiB物理页为大小的空间分配，可以直接分配一整页，回收时也十分方便。对于其他小内存的分配，只需找到用空闲的页，在页中分配空间，回收时也可以根据所给指针方便的定位所在页，对相应的空间做释放，相应页的brk做调整即可。于是采取了这一方法。

\par 对于已分配的空间，采取了将每一个字节都置为设定的Magic，对于最后一个字节置为特定的Mark，便于kfree时确定待free的空间。

\par 对于处理并发的问题，选择了之间用一把大的自旋锁来处理。每次kalloc或者kfree，都必须要获得这把锁，否则就在处理器上自旋，自旋锁的实现采用了课上所讲的atomic-xchg方法。

\subsubsection{实验感想}
\par kalloc的分配方式参考了trivial-os中那个ROUNDUP函数，实际上abstract-machine的框架代码中有这个宏，但trivial-os的实现方式过于简单，没有实现地址对齐，会出现not aligned的错误。因此，自己实现kalloc时，做了相应的调整。

\par 并发问题的处理果然还是比想象之中难很多，自己设计简单的测试样例也很可能由于没有考虑处理好并发而产生令人困惑的结果，例如for循环的循环变量和printf。

\par 感觉白板编程的挑战十分巨大，要同时确保程序代码和测试代码的正确性实在不是一件轻松的事情。

\subsection{L2}
\par 尝试根据thread-os.c以及thread-os-mp.c的代码尝试复现了一个能够在给定了线程数目情况下，将线程绑定到固定处理器上的轮转调度的实现，但在实际的OJ反馈上，遇到了CPU Reset的问题，后续没有成功解决这一问题。

\subsection{L3}
\par 未开始L3的实验。
\end{document}
